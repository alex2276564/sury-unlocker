// ================================================================
// üîÑ Renovate Configuration
// ================================================================
// Universal dependency automation config for any project type.
// Designed for security-first auto-updates with minimal manual intervention.
//
// üìñ Documentation: https://docs.renovatebot.com
// üéØ Philosophy:
//    - Security updates: immediate auto-merge
//    - Stable releases: wait 3 days before updating
//    - Patch/minor: auto-merge (after stabilization)
//    - Major: manual review (breaking changes)
//    - Dev dependencies: grouped into single PR (less spam)
//
// üîß To adapt for other projects:
//    1. Update enabledManagers (npm, composer, pip, etc.)
//    2. Adjust matchManagers in packageRules
//    3. Customize project-specific ignore rules
// ================================================================
// ‚ö†Ô∏è SECURITY NOTE
// -----------------
// Regardless of which schedule mode you choose below (Option 1 / Option 2),
// it's strongly recommended to run Renovate at least once per day
// (via cron or CI).
//
// Reason:
//   ‚Ä¢ vulnerabilityAlerts PRs ignore Renovate's "schedule" filter,
//     but they are only created when the Renovate process actually runs.
//   ‚Ä¢ If Renovate runs only once per week, security fixes (based on
//     GitHub Dependabot alerts, OSV, etc.) can be delayed by up to a week.
//   ‚Ä¢ For Internet‚Äëfacing or security‚Äësensitive projects, a daily
//     Renovate run is a good baseline.

{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",

  // ================================================================
  // üéØ CORE CONFIGURATION
  // ================================================================
  // Base presets define sensible defaults for most projects
  // ================================================================

  "extends": [
    "config:recommended"      // Recommended baseline config
  ],

  // ================================================================
  // ‚è∞ SCHEDULE & TIMING
  // ================================================================
  // Controls when Renovate creates PRs for dependency updates.
  //
  // üí° KEY CONCEPT: Day-only schedules vs Time-specific schedules
  // ----------------------------------------------------------------
  // Day-only (recommended):   "on monday", "every weekend"
  // Time-specific (complex):  "before 6am on monday", "after 10pm"
  //
  // ‚ö†Ô∏è WHY AVOID time-specific schedules?
  // ----------------------------------------------------------------
  // Time-based schedules create synchronization issues:
  //
  // 1. Timezone complexity:
  //    - Your VPS cron runs in timezone A (e.g., UTC)
  //    - GitHub Actions runs in timezone B (e.g., America/New_York)
  //    - Mend.io cloud runs in unknown timezone C
  //    - Result: Same config behaves differently everywhere!
  //
  // 2. Clock drift and DST:
  //    - System clocks may be slightly off
  //    - Daylight Saving Time changes offset
  //    - Edge cases near midnight (is it Monday or Tuesday?)
  //
  // 3. Maintenance burden:
  //    - Moving servers ‚Üí recalculate time offsets
  //    - Adding CI environments ‚Üí debug schedule mismatches
  //    - Time-specific logic is hard to reason about
  //
  // ‚úÖ SOLUTION: Two-level scheduling architecture
  // ----------------------------------------------------------------
  // Separate WHEN (cron) from WHICH DAYS (renovate.json):
  //
  //   Level 1 - Cron (VPS/CI):
  //     Controls execution frequency (when Renovate process starts)
  //     Example: 0 1 * * * = daily at 01:00
  //
  //   Level 2 - Schedule (renovate.json):
  //     Controls PR creation days (which days PRs are allowed)
  //     Example: "on monday" = only Mondays (any time of day)
  //
  // Benefits:
  //   ‚Ä¢ No time synchronization needed (only day matters)
  //   ‚Ä¢ Same config works across all environments
  //   ‚Ä¢ Easy to understand and maintain
  //
  // ================================================================
  // üìã OPTION 1: Universal (Recommended for flexibility)
  // ================================================================
  // Best for: Multiple repos with different schedules
  //
  // Setup:
  // ------
  // VPS Cron (run Renovate daily):
  //   0 1 * * * /root/renovate/run-renovate.sh
  //
  // renovate.json (filter which days to create PRs):
  //   "schedule": ["on monday"]  ‚Üê This setting (day-based)
  //
  // How it works:
  // -------------
  // ‚Ä¢ Renovate runs:  7 times/week (cron: every day at 01:00)
  // ‚Ä¢ PRs created:    1 time/week (schedule: Monday only)
  // ‚Ä¢ Wasted runs:    6/week (Renovate exits early on non-Monday)
  //
  // ‚úÖ Pros:
  //   ‚Ä¢ Universal: Works on VPS, GitHub Actions, GitLab CI, Mend.io
  //   ‚Ä¢ Flexible: Different repos can use different days
  //     - Repo A: "on monday"    ‚Üí PRs on Monday
  //     - Repo B: "on wednesday" ‚Üí PRs on Wednesday
  //     - All use same cron (daily), different schedules filter
  //   ‚Ä¢ No timezone issues: "on monday" matches any time on Monday
  //   ‚Ä¢ Add/remove repos: No cron changes needed
  //
  // ‚ö†Ô∏è Cons:
  //   ‚Ä¢ Resource usage: Renovate starts 6 extra times (does nothing)
  //   ‚Ä¢ Minimal impact: Each wasted run takes ~5-10 seconds
  //
  // üí° TL;DR:
  // Run Renovate daily via cron, let renovate.json filter days.
  // You can deploy multiple Renovate instances across different
  // servers/CI systems without worrying about time synchronization.
  // Each repo's schedule is self-contained and portable.
  //
  // ================================================================
  // üìã OPTION 2: Optimized (Recommended for single schedule)
  // ================================================================
  // Best for: All repos update on same day, want to save resources
  //
  // ‚ö†Ô∏è  WARNING: Security trade-off
  // ----------------------------------------------------------------
  // This option runs Renovate less frequently (e.g., only on Mondays).
  // While vulnerabilityAlerts bypass the schedule restriction, they
  // can only be created when Renovate is actually running.
  //
  // Security implications:
  //   ‚Ä¢ CVE published on Tuesday ‚Üí not detected until next Monday
  //   ‚Ä¢ Vulnerability window: up to 6-7 days
  //   ‚Ä¢ Acceptable ONLY for:
  //     - Internal/private applications (not internet-facing)
  //     - Development/testing environments
  //     - Applications where security is not critical
  //
  // ‚ùå DO NOT USE for:
  //   ‚Ä¢ Public-facing web applications
  //   ‚Ä¢ Production systems handling sensitive data
  //   ‚Ä¢ Applications exposed to the internet
  //   ‚Ä¢ Any security-critical infrastructure
  //
  // If security is important, use OPTION 1 (daily execution) instead.
  // ----------------------------------------------------------------
  //
  // Setup:
  // ------
  // VPS Cron (run Renovate only on Monday):
  //   0 1 * * 1 /root/renovate/run-renovate.sh
  //   #       ‚Üë
  //   #       ‚îî‚îÄ 1 = Monday (0=Sun, 1=Mon, ..., 6=Sat)
  //
  // renovate.json (allow PRs any time):
  //   "schedule": ["at any time"]  # or omit entirely (default)
  //
  // How it works:
  // -------------
  // ‚Ä¢ Renovate runs:  1 time/week (cron: Monday only)
  // ‚Ä¢ PRs created:    1 time/week (schedule: always allowed)
  // ‚Ä¢ Wasted runs:    0/week (runs only when needed)
  // ‚Ä¢ Security fixes: Delayed up to 6-7 days ‚ö†Ô∏è
  //
  // ‚úÖ Pros:
  //   ‚Ä¢ Efficient: No wasted Renovate executions
  //   ‚Ä¢ Simple: One schedule to maintain (in cron)
  //   ‚Ä¢ Resource-friendly: VPS not taxed on unused days
  //
  // ‚ö†Ô∏è Cons:
  //   ‚Ä¢ Security risk: Vulnerabilities detected only once per week
  //   ‚Ä¢ Less flexible: All repos must use same day
  //     - If you want Repo B on Wednesday ‚Üí must add second cron job
  //   ‚Ä¢ Portability: Moving to different CI requires cron reconfiguration
  //   ‚Ä¢ Multi-environment: Harder to sync if using VPS + GitHub Actions
  //
  // üí° TL;DR:
  // Control schedule entirely via cron, renovate.json has no day filter.
  // More efficient but LESS SECURE. Only use for non-critical applications.
  // For production systems, use OPTION 1 with daily cron execution.
  // ================================================================
  // üéØ SCHEDULE SYNTAX REFERENCE
  // ================================================================
  // Common patterns (day-based, timezone-safe):
  // -------------------------------------------
  // "at any time"       ‚Üí No filtering (always allowed)
  // "on monday"         ‚Üí Any time Monday (00:00-23:59 in any TZ)
  // "on friday"         ‚Üí Any time Friday
  // "every weekend"     ‚Üí Saturday and Sunday
  // "every weekday"     ‚Üí Monday through Friday
  //
  // Time-specific patterns (avoid unless necessary):
  // ------------------------------------------------
  // "before 6am on monday"     ‚Üí ‚ö†Ô∏è Timezone-dependent
  // "after 10pm every weekday" ‚Üí ‚ö†Ô∏è Complex to synchronize
  // ================================================================

  "schedule": [
    "on monday"  // OPTION 1: Day-only schedule (timezone-safe, portable)
  ],

  "timezone": "UTC",  // Reference timezone for schedule string parsing
                      // Note: For day-only schedules like "on monday",
                      // timezone setting has minimal effect (day boundaries
                      // are fuzzy). Mainly matters for time-specific schedules.

  // ================================================================
  // üîí LOCK FILE MAINTENANCE
  // ================================================================
  // Periodic refresh of lock files without changing manifests.
  //
  // What it does:
  //   ‚Ä¢ Deletes lock file(s) and regenerates them using the package manager
  //   ‚Ä¢ Updates ALL transitive dependencies to the latest compatible versions
  //   ‚Ä¢ Manifest files (build.gradle, package.json, etc.) remain unchanged
  //   ‚Ä¢ Creates a dedicated PR that contains only lock file changes
  //
  // Safety notes:
  //   ‚Ä¢ Lock file maintenance never goes beyond the version ranges
  //     defined in your manifests.
  //       Example:
  //         "^1.2.3" ‚Üí may update to the latest 1.x.x, but never to 2.x.x.
  //   ‚Ä¢ Even though these PRs are not split by patch/minor/major,
  //     major upgrades normally cannot happen until you relax the ranges
  //     in the manifest itself.
  //
  // Scheduling:
  //   ‚Ä¢ The top-level "schedule" (e.g. ["on monday"]) restricts ALL update
  //     types (regular dependency updates, lock file maintenance, etc.),
  //     so Renovate will create/update branches and PRs only when it matches.
  //   ‚Ä¢ Here we set "schedule": ["at any time"] to override the local default
  //     "before 4am on monday" and avoid conflicting schedules.
  //     Effective behavior:
  //       ‚Üí lockFileMaintenance runs whenever the top-level schedule allows it.
  //         (Global and local schedules are combined with AND conditions, not OR.)
  // ================================================================
  "lockFileMaintenance": {
    "enabled": true,
    "schedule": [
      "at any time" // Make local schedule non-restrictive so only the global schedule matters (AND conditions, not OR).
    ],
    "automerge": true,
    "commitMessagePrefix": "[Lockfile] "
  },

  // ================================================================
  // üéõÔ∏è RATE LIMITING
  // ================================================================
  // Prevents PR/MR spam and controls update flow
  //
  // Recommended values:
  // - Small projects: 5-10 concurrent
  // - Medium projects: 10-20 concurrent
  // - Large monorepos: 20-50 concurrent
  // ================================================================

  "prConcurrentLimit": 10,    // Max 10 PRs open at once
  "prHourlyLimit": 0,         // No hourly limit (controlled by concurrent only)

  // ================================================================
  // üîß PACKAGE MANAGERS
  // ================================================================
  // Explicitly enable only the managers you need for better performance.
  // Renovate auto-detects but explicit config is more predictable.
  //
  // Common managers:
  // - gradle, maven (Java/Kotlin)
  // - npm, yarn, pnpm (JavaScript/TypeScript)
  // - composer (PHP)
  // - pip, pipenv, poetry (Python)
  // - bundler (Ruby)
  // - cargo (Rust)
  // - gomod (Go)
  // - docker, dockerfile
  // - github-actions, circleci, gitlab-ci
  //
  // üìù Customize this list for your project stack!
  // ================================================================

  "enabledManagers": [
    "github-actions"          // GitHub Actions: .github/workflows/*.yml
  ],

  // ================================================================
  // üîê SECURITY SETTINGS
  // ================================================================
  // Stability and security policies for dependency updates
  // ================================================================

  // Wait N days before updating to a new version (except security fixes)
  // This allows time for community to discover critical bugs in new releases
  // Security updates bypass this delay (minimumReleaseAge ignores vulnerabilityAlerts)
  "minimumReleaseAge": "3 days",

  // OSV (Open Source Vulnerabilities) integration
  // Provides additional vulnerability data beyond GitHub Security Advisories
  "osvVulnerabilityAlerts": true,

  // ================================================================
  // ü§ñ AUTO-MERGE CONFIGURATION
  // ================================================================
  // Controls how and when PRs are automatically merged
  //
  // Strategies:
  // 1. platformAutomerge: true
  //    - Uses GitHub/GitLab native auto-merge
  //    - Requires Branch Protection rules
  //    - Waits for required status checks
  //
  // 2. platformAutomerge: false + automergeType: "pr"
  //    - Renovate merges directly via API
  //    - Does NOT require Branch Protection
  //    - Controlled by ignoreTests setting
  //
  // Current config: Strategy 2 (no Branch Protection required)
  // ================================================================

  "automerge": false,             // Don't auto-merge by default (use packageRules)

  "platformAutomerge": false,     // Don't use native GitHub/GitLab auto-merge
                                  // (‚ö†Ô∏è would require Branch Protection)

  "automergeType": "pr",          // Renovate merges PRs directly via API

  "automergeStrategy": "squash",  // Squash commits when merging (clean history)

  "ignoreTests": true,            // Merge immediately without waiting for CI
                                  // Set to false if you want to wait for CI
                                  // (‚ö†Ô∏è requires more complex setup with Branch Protection)

  // ================================================================
  // üì¶ DEPENDENCY UPDATE RULES
  // ================================================================
  // Fine-grained policies per dependency type, ecosystem, or version bump
  //
  // Rule matching is based on:
  // - matchManagers: which package manager (gradle, npm, pip, etc.)
  // - matchUpdateTypes: version bump type (major, minor, patch)
  // - matchPackageNames: specific package names
  // - matchPackagePatterns: regex pattern for package names
  // - matchDepTypes: dependency type (dependencies, devDependencies, etc.)
  //
  // Rules are evaluated top-to-bottom; later rules override earlier ones
  // ================================================================

  "packageRules": [

    // ================================================================
    // üîÑ UPDATE CHANNELS (Patch/Minor/Major)
    // ================================================================
    // Define auto-merge behavior per semantic version bump type
    // ================================================================

    {
      "description": "üü¢ Patch updates: auto-merge (bug fixes, backwards-compatible)",
      "matchUpdateTypes": ["patch"],
      "automerge": true,
      // Examples: 1.2.3 ‚Üí 1.2.4, 2.0.0 ‚Üí 2.0.1
      // Should be safe to auto-merge (except for known buggy releases)
    },

    {
      "description": "üü° Minor updates: auto-merge (new features, backwards-compatible)",
      "matchUpdateTypes": ["minor"],
      "automerge": true,
      // Examples: 1.2.0 ‚Üí 1.3.0, 2.0.0 ‚Üí 2.1.0
      // Usually safe if project follows semantic versioning
    },

    {
      "description": "üî¥ Major updates: manual review (breaking changes expected)",
      "matchUpdateTypes": ["major"],
      "automerge": false,
      // Examples: 1.0.0 ‚Üí 2.0.0, 2.5.3 ‚Üí 3.0.0
      // Requires manual review: API changes, deprecations, migrations
    },

    // ================================================================
    // üì¶ DEV / TEST DEPENDENCIES GROUPING
    // ================================================================
    // Group all development/test dependencies into a single PR to
    // reduce noise. This is generic and can be adapted per ecosystem.
    //
    // Notes:
    // - matchDepTypes values are manager-specific.
    // - For npm:        devDependencies, optionalDependencies (etc.)
    // - For Composer:   require-dev
    // - For Gradle:     configuration names (testImplementation, etc.)
    // - For Maven:      test, provided (depending on setup)
    //
    // Adjust the list below to match your actual stack.
    // ================================================================
    {
      "description": "üì¶ Group all dev/test dependencies into a single PR",
      "matchDepTypes": [
        // Node.js / npm / yarn
        "devDependencies",
        "optionalDependencies",

        // PHP / Composer
        "require-dev",

        // Generic "test" buckets
        "test",
        "testDependencies",

        // Gradle configurations used for tests/dev
        "testCompileOnly",
        "testImplementation",
        "testRuntimeOnly",
        "testAnnotationProcessor"
      ],
      "groupName": "Dev / Test dependencies",
      "groupSlug": "dev-test-deps",
      // Do NOT split by major/minor/patch inside this group:
      "separateMajorMinor": false,
      "separateMinorPatch": false
    },

    // ================================================================
    // üí¨ COMMIT MESSAGE FORMATTING
    // ================================================================
    // Customize commit messages per package manager
    //
    // Default format (with semanticCommits: enabled):
    //   "chore(deps): update dependency foo to v2.0.0"
    //
    // Custom format (with semanticCommits: disabled):
    //   "[Manager] Update dependency foo to v2.0.0"
    //
    // üìù Adapt these rules for your package managers:
    //    - Gradle ‚Üí [Gradle]
    //    - npm ‚Üí [npm]
    //    - Composer ‚Üí [Composer]
    //    - pip ‚Üí [Python]
    // ================================================================

    {
      "description": "üí¨ Gradle: custom commit message prefix",
      "matchManagers": ["gradle", "gradle-wrapper"],
      "commitMessagePrefix": "[Gradle] ",
      "semanticCommits": "disabled",
      // Example: "[Gradle] Update dependency com.google.guava:guava to v32.0.0"
    },

    {
      "description": "üí¨ GitHub Actions: custom commit message prefix",
      "matchManagers": ["github-actions"],
      "commitMessagePrefix": "[GitHub Actions] ",
      "semanticCommits": "disabled",
      // Example: "[GitHub Actions] Update actions/checkout action to v4.2.0"
    },

    // ================================================================
    // üéØ PROJECT-SPECIFIC RULES
    // ================================================================
    // Custom policies for specific dependencies in this project
    //
    // üìù These are project-specific examples. Customize or remove for your project:
    //    - Ignore unstable/breaking dependencies
    //    - Pin specific versions
    //    - Group related updates
    // ================================================================

  ],

  // ================================================================
  // üîê VULNERABILITY ALERTS
  // ================================================================
  // GitHub Security Advisories / Dependabot alerts integration.
  // Renovate reads GitHub vulnerability alerts and raises dedicated
  // security-fix PRs.
  //
  // Behavior:
  //   ‚Ä¢ Ignores global limits like prConcurrentLimit, prHourlyLimit,
  //     branchConcurrentLimit and schedule ‚Üí "skip the line".
  //   ‚Ä¢ PRs are created as soon as an alert is detected (prCreation: "immediate"),
  //     this is prioritizing security over stability.
  //   ‚Ä¢ With automerge: true + ignoreTests: true they are merged immediately.
  //
  // Sources:
  //   ‚Ä¢ GitHub Security Advisories / Dependabot alerts
  //   ‚Ä¢ Optionally OSV, etc. (see osvVulnerabilityAlerts)
  // ================================================================
  "vulnerabilityAlerts": {
    "enabled": true,              // Enable security vulnerability detection
    "automerge": true,             // Auto-merge security fix PRs as soon as they appear
    "labels": ["security", "priority-high"]
  }
}